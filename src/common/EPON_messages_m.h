//
// Generated file, do not edit! Created by opp_msgc 4.1 from common/EPON_messages.msg.
//

#ifndef _EPON_MESSAGES_M_H_
#define _EPON_MESSAGES_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0401
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "Ethernet.h"
#include "EtherFrame_m.h"
#include "MACAddress.h"
#include <inttypes.h>
// }}



/**
 * Class generated from <tt>common/EPON_messages.msg</tt> by opp_msgc.
 * <pre>
 * packet SyncCode
 * {
 *     char code;
 * }
 * </pre>
 */
class SyncCode : public ::cPacket
{
  protected:
    char code_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SyncCode&);

  public:
    SyncCode(const char *name=NULL, int kind=0);
    SyncCode(const SyncCode& other);
    virtual ~SyncCode();
    SyncCode& operator=(const SyncCode& other);
    virtual SyncCode *dup() const {return new SyncCode(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual char getCode() const;
    virtual void setCode(char code_var);
};

inline void doPacking(cCommBuffer *b, SyncCode& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SyncCode& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/EPON_messages.msg</tt> by opp_msgc.
 * <pre>
 * packet EtherFrameWithLLID {
 *     uint16_t llid;
 * }
 * </pre>
 */
class EtherFrameWithLLID : public ::cPacket
{
  protected:
    uint16_t llid_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EtherFrameWithLLID&);

  public:
    EtherFrameWithLLID(const char *name=NULL, int kind=0);
    EtherFrameWithLLID(const EtherFrameWithLLID& other);
    virtual ~EtherFrameWithLLID();
    EtherFrameWithLLID& operator=(const EtherFrameWithLLID& other);
    virtual EtherFrameWithLLID *dup() const {return new EtherFrameWithLLID(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getLlid() const;
    virtual void setLlid(uint16_t llid_var);
};

inline void doPacking(cCommBuffer *b, EtherFrameWithLLID& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, EtherFrameWithLLID& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/EPON_messages.msg</tt> by opp_msgc.
 * <pre>
 * packet MPCP extends EthernetIIFrame
 * {
 *     uint16_t opcode;
 *     uint32_t ts;
 * }
 * </pre>
 */
class MPCP : public ::EthernetIIFrame
{
  protected:
    uint16_t opcode_var;
    uint32_t ts_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MPCP&);

  public:
    MPCP();
    MPCP(const MPCP& other);
    virtual ~MPCP();
    MPCP& operator=(const MPCP& other);
    virtual MPCP *dup() const {return new MPCP(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getOpcode() const;
    virtual void setOpcode(uint16_t opcode_var);
    virtual uint32_t getTs() const;
    virtual void setTs(uint32_t ts_var);
};

inline void doPacking(cCommBuffer *b, MPCP& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MPCP& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/EPON_messages.msg</tt> by opp_msgc.
 * <pre>
 * packet MPCPGate extends MPCP
 * {
 *     uint8_t listLen;
 *     uint32_t startTime[];
 *     uint32_t duration[];
 *     uint16_t slotsNum;
 *     uint16_t slotTime;
 * }
 * </pre>
 */
class MPCPGate : public ::MPCP
{
  protected:
    uint8_t listLen_var;
    uint32_t *startTime_var; // array ptr
    unsigned int startTime_arraysize;
    uint32_t *duration_var; // array ptr
    unsigned int duration_arraysize;
    uint16_t slotsNum_var;
    uint16_t slotTime_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MPCPGate&);

  public:
    MPCPGate();
    MPCPGate(const MPCPGate& other);
    virtual ~MPCPGate();
    MPCPGate& operator=(const MPCPGate& other);
    virtual MPCPGate *dup() const {return new MPCPGate(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getListLen() const;
    virtual void setListLen(uint8_t listLen_var);
    virtual void setStartTimeArraySize(unsigned int size);
    virtual unsigned int getStartTimeArraySize() const;
    virtual uint32_t getStartTime(unsigned int k) const;
    virtual void setStartTime(unsigned int k, uint32_t startTime_var);
    virtual void setDurationArraySize(unsigned int size);
    virtual unsigned int getDurationArraySize() const;
    virtual uint32_t getDuration(unsigned int k) const;
    virtual void setDuration(unsigned int k, uint32_t duration_var);
    virtual uint16_t getSlotsNum() const;
    virtual void setSlotsNum(uint16_t slotsNum_var);
    virtual uint16_t getSlotTime() const;
    virtual void setSlotTime(uint16_t slotTime_var);
};

inline void doPacking(cCommBuffer *b, MPCPGate& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MPCPGate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/EPON_messages.msg</tt> by opp_msgc.
 * <pre>
 * packet MPCPReport extends MPCP
 * {
 *     uint8_t bitMap;
 * 	uint32_t qInfo[];
 * }
 * </pre>
 */
class MPCPReport : public ::MPCP
{
  protected:
    uint8_t bitMap_var;
    uint32_t *qInfo_var; // array ptr
    unsigned int qInfo_arraysize;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MPCPReport&);

  public:
    MPCPReport();
    MPCPReport(const MPCPReport& other);
    virtual ~MPCPReport();
    MPCPReport& operator=(const MPCPReport& other);
    virtual MPCPReport *dup() const {return new MPCPReport(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getBitMap() const;
    virtual void setBitMap(uint8_t bitMap_var);
    virtual void setQInfoArraySize(unsigned int size);
    virtual unsigned int getQInfoArraySize() const;
    virtual uint32_t getQInfo(unsigned int k) const;
    virtual void setQInfo(unsigned int k, uint32_t qInfo_var);
};

inline void doPacking(cCommBuffer *b, MPCPReport& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MPCPReport& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/EPON_messages.msg</tt> by opp_msgc.
 * <pre>
 * packet MPCPRegReq extends MPCP
 * {
 *     uint8_t ptpNumReq;
 * }
 * </pre>
 */
class MPCPRegReq : public ::MPCP
{
  protected:
    uint8_t ptpNumReq_var;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MPCPRegReq&);

  public:
    MPCPRegReq();
    MPCPRegReq(const MPCPRegReq& other);
    virtual ~MPCPRegReq();
    MPCPRegReq& operator=(const MPCPRegReq& other);
    virtual MPCPRegReq *dup() const {return new MPCPRegReq(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getPtpNumReq() const;
    virtual void setPtpNumReq(uint8_t ptpNumReq_var);
};

inline void doPacking(cCommBuffer *b, MPCPRegReq& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MPCPRegReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/EPON_messages.msg</tt> by opp_msgc.
 * <pre>
 * packet MPCPRegister extends MPCP
 * {
 *     uint8_t ptpNumReg;
 *     uint16_t LLIDs[];
 * }
 * </pre>
 */
class MPCPRegister : public ::MPCP
{
  protected:
    uint8_t ptpNumReg_var;
    uint16_t *LLIDs_var; // array ptr
    unsigned int LLIDs_arraysize;

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MPCPRegister&);

  public:
    MPCPRegister();
    MPCPRegister(const MPCPRegister& other);
    virtual ~MPCPRegister();
    MPCPRegister& operator=(const MPCPRegister& other);
    virtual MPCPRegister *dup() const {return new MPCPRegister(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getPtpNumReg() const;
    virtual void setPtpNumReg(uint8_t ptpNumReg_var);
    virtual void setLLIDsArraySize(unsigned int size);
    virtual unsigned int getLLIDsArraySize() const;
    virtual uint16_t getLLIDs(unsigned int k) const;
    virtual void setLLIDs(unsigned int k, uint16_t LLIDs_var);
};

inline void doPacking(cCommBuffer *b, MPCPRegister& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MPCPRegister& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>common/EPON_messages.msg</tt> by opp_msgc.
 * <pre>
 * packet MPCPRegAck extends MPCP
 * {
 * }
 * </pre>
 */
class MPCPRegAck : public ::MPCP
{
  protected:

    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MPCPRegAck&);

  public:
    MPCPRegAck();
    MPCPRegAck(const MPCPRegAck& other);
    virtual ~MPCPRegAck();
    MPCPRegAck& operator=(const MPCPRegAck& other);
    virtual MPCPRegAck *dup() const {return new MPCPRegAck(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, MPCPRegAck& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MPCPRegAck& obj) {obj.parsimUnpack(b);}


#endif // _EPON_MESSAGES_M_H_
